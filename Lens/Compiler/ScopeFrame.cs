using System;
using System.Collections.Generic;
using Lens.Compiler.Entities;
using Lens.Translations;

namespace Lens.Compiler
{
	/// <summary>
	/// A list of variables defined in a particular code block.
	/// </summary>
	internal class ScopeFrame
	{
		public ScopeFrame()
		{
			Names = new Dictionary<string, LocalName>();
		}

		/// <summary>
		/// The lookup table of names defined in current scope.
		/// </summary>
		public readonly Dictionary<string, LocalName> Names;

		/// <summary>
		/// The pointer to containing low-level scope.
		/// </summary>
		public Scope Scope;

		/// <summary>
		/// The pointer to containing frame.
		/// </summary>
		public ScopeFrame OuterFrame;

		#region Methods

		/// <summary>
		/// Bind the current frame settings to actual values.
		/// </summary>
		public void InitializeScopeFrame(Context ctx)
		{
			if (Scope != null)
				return;

			Scope = ctx.CurrentScope;
			Scope.RegisterFrame(this);
			OuterFrame = ctx.CurrentScopeFrame;
		}

		private void checkInit()
		{
			if(Scope == null)
				throw new InvalidOperationException("Scope frame is not initialized!");
		}

		/// <summary>
		/// Gets information about a local name.
		/// </summary>
		public LocalName FindName(string name)
		{
			checkInit();

			LocalName local = null;
			find(name, (loc, idx) => local = loc.GetClosuredCopy(idx));
			return local;
		}

		/// <summary>
		/// Declares a new name in the current scope.
		/// </summary>
		public LocalName DeclareName(string name, Type type, bool isConst, bool isRefArg = false)
		{
			checkInit();

			if (find(name))
				throw new LensCompilerException(string.Format(CompilerMessages.VariableDefined, name));

			var n = new LocalName(name, type, isConst, isRefArg);
			Names[name] = n;
			return n;
		}

		/// <summary>
		/// Declares a new variable with autogenerated name.
		/// This name cannot be closured.
		/// </summary>
		public LocalName DeclareImplicitName(Context ctx, Type type, bool isConst)
		{
			checkInit();

			var lb = ctx.CurrentILGenerator.DeclareLocal(type);
			var name = string.Format(EntityNames.ImplicitVariableNameTemplate, lb.LocalIndex);
			var ln = new LocalName(name, type, isConst) { LocalBuilder = lb };
			Names[name] = ln;
			return ln;
		}

		/// <summary>
		/// Declares a new temp variable that is instantly initialized.
		/// </summary>
		public LocalName DeclareInternalName(string name, Context ctx, Type type, bool isConst)
		{
			checkInit();

			var lb = ctx.CurrentILGenerator.DeclareLocal(type);
			var ln = new LocalName(name, type, isConst) { LocalBuilder = lb };
			Names[name] = ln;
			return ln;
		}

		/// <summary>
		/// Checks if the variable is being referenced in another scope.
		/// </summary>
		public void ReferenceName(string name)
		{
			checkInit();

			var found = find(
				name,
				(loc, idx) =>
				{
					var closured = idx > 0;
					if (closured)
					{
						if (loc.LocalBuilder != null)
							throw new InvalidOperationException(CompilerMessages.ClosureImplicit);

						if (loc.IsRefArgument)
							throw new LensCompilerException(CompilerMessages.ClosureRef);
					}

					loc.IsClosured |= closured;
				}
			);

			if (!found)
				throw new LensCompilerException(string.Format(CompilerMessages.VariableNotFound, name));
		}

		/// <summary>
		/// Creates a closured method in the current scope's closure type using function argument records.
		/// </summary>
		public MethodEntity CreateClosureMethod(Context ctx, IEnumerable<FunctionArgument> args, TypeSignature returnType = null)
		{
			checkInit();

			return Scope.CreateClosureMethod(ctx, this, args, returnType);
		}

		/// <summary>
		/// Creates a closured method in the current scope's closure type using argument types.
		/// </summary>
		public MethodEntity CreateClosureMethod(Context ctx, Type[] args, Type returnType = null)
		{
			checkInit();

			return Scope.CreateClosureMethod(ctx, this, args, returnType);
		}

		/// <summary>
		/// Finds a local name and invoke a callback.
		/// </summary>
		private bool find(string name, Action<LocalName, int> action = null)
		{
			var idx = 0;
			var frame = this;
			while (frame != null)
			{
				LocalName loc;
				if (frame.Names.TryGetValue(name, out loc))
				{
					if (action != null)
						action(loc, idx);
					return true;
				}

				if(frame == frame.Scope.RootFrame)
					idx++;

				frame = frame.OuterFrame;
			}

			return false;
		}

		#endregion
	}
}
