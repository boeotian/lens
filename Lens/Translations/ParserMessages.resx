<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgTypeExpected" xml:space="preserve">
    <value>LE2001: Argument type is expected!</value>
  </data>
  <data name="ArgumentPassIndentExpected" xml:space="preserve">
    <value>LE2002: '&lt;|' statements must be indented!</value>
  </data>
  <data name="ArgumentsExpected" xml:space="preserve">
    <value>LE2003: Method call arguments are expected!</value>
  </data>
  <data name="ArrayItem" xml:space="preserve">
    <value>LE2004: An array must contain at least one item!</value>
  </data>
  <data name="AssignExpressionExpected" xml:space="preserve">
    <value>LE2005: Assignment expression is expected!</value>
  </data>
  <data name="AssignLvalueExpected" xml:space="preserve">
    <value>LE2006: The expression at left side cannot be assigned to!</value>
  </data>
  <data name="CatchExpected" xml:space="preserve">
    <value>LE2007: Catch clause is expected!</value>
  </data>
  <data name="ClosingBraceNewLine" xml:space="preserve">
    <value>LE2008: Closing brace must be placed on the next line!</value>
  </data>
  <data name="CodeBlockExpected" xml:space="preserve">
    <value>LE2009: Code block is expected!</value>
  </data>
  <data name="ConditionBlockExpected" xml:space="preserve">
    <value>LE2010: Condition block is expected!</value>
  </data>
  <data name="ConditionExpected" xml:space="preserve">
    <value>LE2011: Condition is expected!</value>
  </data>
  <data name="ConditionExpressionExpected" xml:space="preserve">
    <value>LE2012: Condition expression is expected!</value>
  </data>
  <data name="DictionaryItem" xml:space="preserve">
    <value>LE2013: A dictionary must contain at least one item!</value>
  </data>
  <data name="DictionaryKeyExpected" xml:space="preserve">
    <value>LE2014: Dictionary key expression is expected!</value>
  </data>
  <data name="DictionaryValueExpected" xml:space="preserve">
    <value>LE2015: Dictionary value expression is expected!</value>
  </data>
  <data name="ExceptionHandlerExpected" xml:space="preserve">
    <value>LE2016: Exception handler code block is expected!</value>
  </data>
  <data name="ExceptionTypeExpected" xml:space="preserve">
    <value>LE2017: Exception type signature is expected!</value>
  </data>
  <data name="ExpressionExpected" xml:space="preserve">
    <value>LE2018: Expression is expected!</value>
  </data>
  <data name="FunctionBodyExpected" xml:space="preserve">
    <value>LE2019: Function body is expected!</value>
  </data>
  <data name="FunctionDefExpected" xml:space="preserve">
    <value>LE2020: Function definition is expected!</value>
  </data>
  <data name="FunctionIdentifierExpected" xml:space="preserve">
    <value>LE2021: Function name must be an identifier!</value>
  </data>
  <data name="FunctionReturnExpected" xml:space="preserve">
    <value>LE2022: Function return type is expected!</value>
  </data>
  <data name="IdentifierExpected" xml:space="preserve">
    <value>LE2023: An identifier is expected!</value>
  </data>
  <data name="IndexExpressionExpected" xml:space="preserve">
    <value>LE2024: Index expression is expected!</value>
  </data>
  <data name="InitExpressionExpected" xml:space="preserve">
    <value>LE2025: Initializer expression is expected!</value>
  </data>
  <data name="InitExpressionOrTypeExpected" xml:space="preserve">
    <value>LE2026: Initializer expression or type signature is expected!</value>
  </data>
  <data name="InitExpressionSeparatorExpected" xml:space="preserve">
    <value>LE2027: Initializer expressions must be separated by a newline!</value>
  </data>
  <data name="InitializerIndentExprected" xml:space="preserve">
    <value>LE2028: Initializer expressions must be indented!</value>
  </data>
  <data name="InvalidDouble" xml:space="preserve">
    <value>LE2029: Value '{0}' is not a valid double!</value>
  </data>
  <data name="InvalidInteger" xml:space="preserve">
    <value>LE2030: Value '{0}' is not a valid integer!</value>
  </data>
  <data name="InvokePassSeparatorExpected" xml:space="preserve">
    <value>LE2031: Invoke passes must be separated by a newline!</value>
  </data>
  <data name="ListItem" xml:space="preserve">
    <value>LE2032: A list must contain at least one item!</value>
  </data>
  <data name="LoopBodyExpected" xml:space="preserve">
    <value>LE2033: Loop body block is expected!</value>
  </data>
  <data name="LoopExpressionExpected" xml:space="preserve">
    <value>LE2034: Loop body expression is expected!</value>
  </data>
  <data name="MemberNameExpected" xml:space="preserve">
    <value>LE2035: Member name is expected!</value>
  </data>
  <data name="MethodPassIndentExpected" xml:space="preserve">
    <value>LE2036: '|&gt;' statements must be indented!</value>
  </data>
  <data name="NamespaceExpected" xml:space="preserve">
    <value>LE2037: A namespace is expected!</value>
  </data>
  <data name="NewlineSeparatorExpected" xml:space="preserve">
    <value>LE2038: Statements must be separated by newlines!</value>
  </data>
  <data name="RangeEndExpected" xml:space="preserve">
    <value>LE2039: Range end expression is expected!</value>
  </data>
  <data name="RecordFieldIdentifierExpected" xml:space="preserve">
    <value>LE2040: Record field name must be an identifier!</value>
  </data>
  <data name="RecordFieldTypeExpected" xml:space="preserve">
    <value>LE2041: Record field type signature is expected!</value>
  </data>
  <data name="RecordIdentifierExpected" xml:space="preserve">
    <value>LE2042: Record name must be an identifier!</value>
  </data>
  <data name="RecordIndentExpected" xml:space="preserve">
    <value>LE2043: Record body must be indented block!</value>
  </data>
  <data name="RecordSeparatorExpected" xml:space="preserve">
    <value>LE2044: Record fields must be separated by a newline!</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>LE2045: The 'ref' modifier can only be applied to a variable, a field or an array index!</value>
  </data>
  <data name="SequenceExpected" xml:space="preserve">
    <value>LE2046: Sequence expression is expected!</value>
  </data>
  <data name="SymbolExpected" xml:space="preserve">
    <value>LE2047: '{0}' expected!</value>
  </data>
  <data name="TryBlockExpected" xml:space="preserve">
    <value>LE2048: Try block is expected!</value>
  </data>
  <data name="TupleItem" xml:space="preserve">
    <value>LE2049: A tuple must contain at least one item!</value>
  </data>
  <data name="TypeArgumentExpected" xml:space="preserve">
    <value>LE2050: Type argument is expected!</value>
  </data>
  <data name="TypeIdentifierExpected" xml:space="preserve">
    <value>LE2051: Type name must be an identifier!</value>
  </data>
  <data name="TypeIndentExpected" xml:space="preserve">
    <value>LE2052: Type body must be indented block!</value>
  </data>
  <data name="TypeLabelIdentifierExpected" xml:space="preserve">
    <value>LE2053: Type label name must be an identifier!</value>
  </data>
  <data name="TypeLabelTagTypeExpected" xml:space="preserve">
    <value>LE2054: Tag type signature is expected!</value>
  </data>
  <data name="TypeSeparatorExpected" xml:space="preserve">
    <value>LE2055: Type labels must be separated by a newline!</value>
  </data>
  <data name="TypeSignatureExpected" xml:space="preserve">
    <value>LE2056: Type signature is expected!</value>
  </data>
  <data name="UnknownStatement" xml:space="preserve">
    <value>LE2057: Unknown kind of statement!</value>
  </data>
  <data name="VariadicByRef" xml:space="preserve">
    <value>LE2060: A by-ref argument cannot be marked with '...' modifier!</value>
  </data>
  <data name="VarIdentifierExpected" xml:space="preserve">
    <value>LE2061: Variable name must be an identifier!</value>
  </data>
  <data name="VarTypeExpected" xml:space="preserve">
    <value>LE2062: Variable type is expected!</value>
  </data>
  <data name="UsingBodyExpected" xml:space="preserve">
    <value>LE2058: Resource block body is expected!</value>
  </data>
  <data name="UsingExpressionExpected" xml:space="preserve">
    <value>LE2059: Resource block expression is expected!</value>
  </data>
  <data name="InvalidFloat" xml:space="preserve">
    <value>LE2063: Value '{0}' is not a valid float!</value>
  </data>
  <data name="InvalidLong" xml:space="preserve">
    <value>LE2064: Value '{0}' is not a valid long!</value>
  </data>
  <data name="InvalidDecimal" xml:space="preserve">
    <value>LE2065: Value '{0}' is not a valid decimal!</value>
  </data>
</root>